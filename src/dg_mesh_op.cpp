//
// auto-generated by op2.py
//

#include "dg_mesh.h"

#include  "op_lib_cpp.h"

//
// op_par_loop declarations
//
#ifdef OPENACC
#ifdef __cplusplus
extern "C" {
#endif
#endif

void op_par_loop_init_cubature(char const *, op_set,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg );

void op_par_loop_init_gauss(char const *, op_set,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg );

void op_par_loop_init_nodes(char const *, op_set,
  op_arg,
  op_arg,
  op_arg );

void op_par_loop_init_grid(char const *, op_set,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg );

void op_par_loop_init_edges(char const *, op_set,
  op_arg,
  op_arg,
  op_arg,
  op_arg );
#ifdef OPENACC
#ifdef __cplusplus
}
#endif
#endif


#include <string>
#include <memory>

// #include "constants/all_constants.h"
#include "dg_blas_calls.h"
#include "dg_compiler_defs.h"
#include "dg_constants.h"

DGConstants *constants;

using namespace std;

void set_cuda_const();

DGCubatureData::DGCubatureData(DGMesh *m) {
  mesh = m;

  rx_data    = (double *)calloc(DG_CUB_NP * mesh->numCells, sizeof(double));
  sx_data    = (double *)calloc(DG_CUB_NP * mesh->numCells, sizeof(double));
  ry_data    = (double *)calloc(DG_CUB_NP * mesh->numCells, sizeof(double));
  sy_data    = (double *)calloc(DG_CUB_NP * mesh->numCells, sizeof(double));
  J_data     = (double *)calloc(DG_CUB_NP * mesh->numCells, sizeof(double));
  mm_data    = (double *)calloc(DG_NP * DG_NP * mesh->numCells, sizeof(double));
  tmp_data   = (double *)calloc(DG_CUB_NP * DG_NP * mesh->numCells, sizeof(double));

  for(int i = 0; i < 4; i++) {
    op_tmp_data[i] = (double *)calloc(DG_CUB_NP * mesh->numCells, sizeof(double));
  }

  rx    = op_decl_dat(mesh->cells, DG_CUB_NP, "double", rx_data, "cub-rx");
  sx    = op_decl_dat(mesh->cells, DG_CUB_NP, "double", sx_data, "cub-sx");
  ry    = op_decl_dat(mesh->cells, DG_CUB_NP, "double", ry_data, "cub-ry");
  sy    = op_decl_dat(mesh->cells, DG_CUB_NP, "double", sy_data, "cub-sy");
  J     = op_decl_dat(mesh->cells, DG_CUB_NP, "double", J_data, "cub-J");
  mm    = op_decl_dat(mesh->cells, DG_NP * DG_NP, "double", mm_data, "cub-mm");
  tmp   = op_decl_dat(mesh->cells, DG_CUB_NP * DG_NP, "double", tmp_data, "cub-tmp");

  for(int i = 0; i < 4; i++) {
    string tmpname = "cub-op_tmp" + to_string(i);
    op_tmp[i] = op_decl_dat(mesh->cells, DG_CUB_NP, "double", op_tmp_data[i], tmpname.c_str());
  }
}

DGCubatureData::~DGCubatureData() {
  free(rx_data);
  free(sx_data);
  free(ry_data);
  free(sy_data);
  free(J_data);
  free(mm_data);
  free(tmp_data);

  for(int i = 0; i < 4; i++) {
    free(op_tmp_data[i]);
  }
}

void DGCubatureData::init() {
  // Calculate geometric factors for cubature volume nodes
  op2_gemv(false, DG_CUB_NP, DG_NP, 1.0, constants->get_ptr(DGConstants::CUB_DR), DG_CUB_NP, mesh->x, 0.0, rx);
  op2_gemv(false, DG_CUB_NP, DG_NP, 1.0, constants->get_ptr(DGConstants::CUB_DS), DG_CUB_NP, mesh->x, 0.0, sx);
  op2_gemv(false, DG_CUB_NP, DG_NP, 1.0, constants->get_ptr(DGConstants::CUB_DR), DG_CUB_NP, mesh->y, 0.0, ry);
  op2_gemv(false, DG_CUB_NP, DG_NP, 1.0, constants->get_ptr(DGConstants::CUB_DS), DG_CUB_NP, mesh->y, 0.0, sy);

  op_par_loop_init_cubature("init_cubature",mesh->cells,
              op_arg_dat(rx,-1,OP_ID,DG_CUB_NP,"double",OP_RW),
              op_arg_dat(sx,-1,OP_ID,DG_CUB_NP,"double",OP_RW),
              op_arg_dat(ry,-1,OP_ID,DG_CUB_NP,"double",OP_RW),
              op_arg_dat(sy,-1,OP_ID,DG_CUB_NP,"double",OP_RW),
              op_arg_dat(J,-1,OP_ID,DG_CUB_NP,"double",OP_WRITE),
              op_arg_dat(tmp,-1,OP_ID,DG_CUB_NP * DG_NP,"double",OP_WRITE));
  // Temp is in col-major at this point
  op2_gemm(true, false, DG_NP, DG_NP, DG_CUB_NP, 1.0, constants->get_ptr(DGConstants::CUB_V), DG_CUB_NP, tmp, DG_CUB_NP, 0.0, mm, DG_NP);
  // mm is in col-major at this point
}

DGGaussData::DGGaussData(DGMesh *m) {
  mesh = m;

  x_data  = (double *)calloc(DG_G_NP * mesh->numCells, sizeof(double));
  y_data  = (double *)calloc(DG_G_NP * mesh->numCells, sizeof(double));
  rx_data = (double *)calloc(DG_G_NP * mesh->numCells, sizeof(double));
  sx_data = (double *)calloc(DG_G_NP * mesh->numCells, sizeof(double));
  ry_data = (double *)calloc(DG_G_NP * mesh->numCells, sizeof(double));
  sy_data = (double *)calloc(DG_G_NP * mesh->numCells, sizeof(double));
  sJ_data = (double *)calloc(DG_G_NP * mesh->numCells, sizeof(double));
  nx_data = (double *)calloc(DG_G_NP * mesh->numCells, sizeof(double));
  ny_data = (double *)calloc(DG_G_NP * mesh->numCells, sizeof(double));

  x  = op_decl_dat(mesh->cells, DG_G_NP, "double", x_data, "gauss-x");
  y  = op_decl_dat(mesh->cells, DG_G_NP, "double", y_data, "gauss-y");
  rx = op_decl_dat(mesh->cells, DG_G_NP, "double", rx_data, "gauss-rx");
  sx = op_decl_dat(mesh->cells, DG_G_NP, "double", sx_data, "gauss-sx");
  ry = op_decl_dat(mesh->cells, DG_G_NP, "double", ry_data, "gauss-ry");
  sy = op_decl_dat(mesh->cells, DG_G_NP, "double", sy_data, "gauss-sy");
  sJ = op_decl_dat(mesh->cells, DG_G_NP, "double", sJ_data, "gauss-sJ");
  nx = op_decl_dat(mesh->cells, DG_G_NP, "double", nx_data, "gauss-nx");
  ny = op_decl_dat(mesh->cells, DG_G_NP, "double", ny_data, "gauss-ny");
}

DGGaussData::~DGGaussData() {
  free(x_data);
  free(y_data);
  free(rx_data);
  free(sx_data);
  free(ry_data);
  free(sy_data);
  free(sJ_data);
  free(nx_data);
  free(ny_data);
}

void DGGaussData::init() {
  op2_gemv(false, DG_G_NP, DG_NP, 1.0, constants->get_ptr(DGConstants::GAUSS_INTERP), DG_G_NP, mesh->x, 0.0, x);
  op2_gemv(false, DG_G_NP, DG_NP, 1.0, constants->get_ptr(DGConstants::GAUSS_INTERP), DG_G_NP, mesh->y, 0.0, y);

  // Initialise geometric factors for Gauss nodes
  init_gauss_blas(mesh, this);

  op_par_loop_init_gauss("init_gauss",mesh->cells,
              op_arg_dat(rx,-1,OP_ID,DG_G_NP,"double",OP_RW),
              op_arg_dat(sx,-1,OP_ID,DG_G_NP,"double",OP_RW),
              op_arg_dat(ry,-1,OP_ID,DG_G_NP,"double",OP_RW),
              op_arg_dat(sy,-1,OP_ID,DG_G_NP,"double",OP_RW),
              op_arg_dat(nx,-1,OP_ID,DG_G_NP,"double",OP_WRITE),
              op_arg_dat(ny,-1,OP_ID,DG_G_NP,"double",OP_WRITE),
              op_arg_dat(sJ,-1,OP_ID,DG_G_NP,"double",OP_WRITE));
}

DGMesh::DGMesh(double *coords_a, int *cells_a, int *edge2node_a,
               int *edge2cell_a, int *bedge2node_a, int *bedge2cell_a,
               int *bedge_type_a, int *edgeNum_a, int *bedgeNum_a,
               int numNodes_g_a, int numCells_g_a, int numEdges_g_a,
               int numBoundaryEdges_g_a, int numNodes_a, int numCells_a,
               int numEdges_a, int numBoundaryEdges_a) {
  // Calculate DG constants
  constants = new DGConstants();

  coords_data        = coords_a;
  cells_data         = cells_a;
  edge2node_data     = edge2node_a;
  edge2cell_data     = edge2cell_a;
  bedge2node_data    = bedge2node_a;
  bedge2cell_data    = bedge2cell_a;
  bedge_type_data    = bedge_type_a;
  edgeNum_data       = edgeNum_a;
  bedgeNum_data      = bedgeNum_a;
  numNodes_g         = numNodes_g_a;
  numCells_g         = numCells_g_a;
  numEdges_g         = numEdges_g_a;
  numBoundaryEdges_g = numBoundaryEdges_g_a;
  numNodes           = numNodes_a;
  numCells           = numCells_a;
  numEdges           = numEdges_a;
  numBoundaryEdges   = numBoundaryEdges_a;

  // Initialise memory
  nodeX_data   = (double*)calloc(3 * numCells, sizeof(double));
  nodeY_data   = (double*)calloc(3 * numCells, sizeof(double));
  x_data       = (double *)calloc(DG_NP * numCells, sizeof(double));
  y_data       = (double *)calloc(DG_NP * numCells, sizeof(double));
  rx_data      = (double *)calloc(DG_NP * numCells, sizeof(double));
  ry_data      = (double *)calloc(DG_NP * numCells, sizeof(double));
  sx_data      = (double *)calloc(DG_NP * numCells, sizeof(double));
  sy_data      = (double *)calloc(DG_NP * numCells, sizeof(double));
  nx_data      = (double *)calloc(3 * DG_NPF * numCells, sizeof(double));
  ny_data      = (double *)calloc(3 * DG_NPF * numCells, sizeof(double));
  J_data       = (double *)calloc(DG_NP * numCells, sizeof(double));
  sJ_data      = (double *)calloc(3 * DG_NPF * numCells, sizeof(double));
  fscale_data  = (double *)calloc(3 * DG_NPF * numCells, sizeof(double));
  reverse_data = (bool *)calloc(numEdges, sizeof(bool));
  for(int i = 0; i < 4; i++) {
    op_tmp_data[i] = (double *)calloc(DG_NP * numCells, sizeof(double));
  }

  // Initialise OP2
  // Declare OP2 sets
  nodes  = op_decl_set(numNodes, "nodes");
  cells  = op_decl_set(numCells, "cells");
  edges  = op_decl_set(numEdges, "edges");
  bedges = op_decl_set(numBoundaryEdges, "bedges");

  // Declare OP2 maps
  cell2nodes  = op_decl_map(cells, nodes, 3, cells_data, "cell2nodes");
  edge2nodes  = op_decl_map(edges, nodes, 2, edge2node_data, "edge2nodes");
  edge2cells  = op_decl_map(edges, cells, 2, edge2cell_data, "edge2cells");
  bedge2nodes = op_decl_map(bedges, nodes, 2, bedge2node_data, "bedge2nodes");
  bedge2cells = op_decl_map(bedges, cells, 1, bedge2cell_data, "bedge2cells");

  // Declare OP2 datasets
  // Structure: {x, y}
  node_coords = op_decl_dat(nodes, 2, "double", coords_data, "node_coords");
  // Coords of nodes per cell
  nodeX = op_decl_dat(cells, 3, "double", nodeX_data, "nodeX");
  nodeY = op_decl_dat(cells, 3, "double", nodeY_data, "nodeY");
  // The x and y coordinates of all the solution points in a cell
  x = op_decl_dat(cells, DG_NP, "double", x_data, "x");
  y = op_decl_dat(cells, DG_NP, "double", y_data, "y");
  // Geometric factors that relate to mapping between global and local (cell) coordinates
  rx = op_decl_dat(cells, DG_NP, "double", rx_data, "rx");
  ry = op_decl_dat(cells, DG_NP, "double", ry_data, "ry");
  sx = op_decl_dat(cells, DG_NP, "double", sx_data, "sx");
  sy = op_decl_dat(cells, DG_NP, "double", sy_data, "sy");
  // Normals for each cell (calculated for each node on each edge, nodes can appear on multiple edges)
  nx = op_decl_dat(cells, 3 * DG_NPF, "double", nx_data, "nx");
  ny = op_decl_dat(cells, 3 * DG_NPF, "double", ny_data, "ny");
  // surface Jacobian / Jacobian (used when lifting the boundary fluxes)
  J          = op_decl_dat(cells, DG_NP, "double", J_data, "J");
  sJ         = op_decl_dat(cells, 3 * DG_NPF, "double", sJ_data, "sJ");
  fscale     = op_decl_dat(cells, 3 * DG_NPF, "double", fscale_data, "fscale");
  bedge_type = op_decl_dat(bedges, 1, "int", bedge_type_data, "bedge_type");
  edgeNum    = op_decl_dat(edges, 2, "int", edgeNum_data, "edgeNum");
  bedgeNum   = op_decl_dat(bedges, 1, "int", bedgeNum_data, "bedgeNum");
  reverse    = op_decl_dat(edges, 1, "bool", reverse_data, "reverse");
  for(int i = 0; i < 4; i++) {
    string tmpname = "op_tmp" + to_string(i);
    op_tmp[i] = op_decl_dat(cells, DG_NP, "double", op_tmp_data[i], tmpname.c_str());
  }

  #ifdef OP2_DG_CUDA
  set_cuda_const();
  #else
  op_decl_const2("FMASK",DG_NPF * 3,"int",FMASK);
  op_decl_const2("cubW_g",DG_CUB_NP,"double",cubW_g);
  op_decl_const2("cubV_g",DG_CUB_NP * DG_NP,"double",cubV_g);
  op_decl_const2("cubVDr_g",DG_CUB_NP * DG_NP,"double",cubVDr_g);
  op_decl_const2("cubVDs_g",DG_CUB_NP * DG_NP,"double",cubVDs_g);
  op_decl_const2("gF0Dr_g",DG_GF_NP * DG_NP,"double",gF0Dr_g);
  op_decl_const2("gF0Ds_g",DG_GF_NP * DG_NP,"double",gF0Ds_g);
  op_decl_const2("gF1Dr_g",DG_GF_NP * DG_NP,"double",gF1Dr_g);
  op_decl_const2("gF1Ds_g",DG_GF_NP * DG_NP,"double",gF1Ds_g);
  op_decl_const2("gF2Dr_g",DG_GF_NP * DG_NP,"double",gF2Dr_g);
  op_decl_const2("gF2Ds_g",DG_GF_NP * DG_NP,"double",gF2Ds_g);
  op_decl_const2("gaussW_g",DG_GF_NP,"double",gaussW_g);
  op_decl_const2("gFInterp0_g",DG_GF_NP * DG_NP,"double",gFInterp0_g);
  op_decl_const2("gFInterp1_g",DG_GF_NP * DG_NP,"double",gFInterp1_g);
  op_decl_const2("gFInterp2_g",DG_GF_NP * DG_NP,"double",gFInterp2_g);
  op_decl_const2("gF0DrR_g",DG_GF_NP * DG_NP,"double",gF0DrR_g);
  op_decl_const2("gF0DsR_g",DG_GF_NP * DG_NP,"double",gF0DsR_g);
  op_decl_const2("gF1DrR_g",DG_GF_NP * DG_NP,"double",gF1DrR_g);
  op_decl_const2("gF1DsR_g",DG_GF_NP * DG_NP,"double",gF1DsR_g);
  op_decl_const2("gF2DrR_g",DG_GF_NP * DG_NP,"double",gF2DrR_g);
  op_decl_const2("gF2DsR_g",DG_GF_NP * DG_NP,"double",gF2DsR_g);
  op_decl_const2("gFInterp0R_g",DG_GF_NP * DG_NP,"double",gFInterp0R_g);
  op_decl_const2("gFInterp1R_g",DG_GF_NP * DG_NP,"double",gFInterp1R_g);
  op_decl_const2("gFInterp2R_g",DG_GF_NP * DG_NP,"double",gFInterp2R_g);
  #endif

  cubature = new DGCubatureData(this);
  gauss = new DGGaussData(this);
}

DGMesh::~DGMesh() {
  free(coords_data);
  free(cells_data);
  free(edge2node_data);
  free(edge2cell_data);
  free(bedge2node_data);
  free(bedge2cell_data);
  free(bedge_type_data);
  free(edgeNum_data);
  free(bedgeNum_data);

  free(nodeX_data);
  free(nodeY_data);
  free(x_data);
  free(y_data);
  free(rx_data);
  free(ry_data);
  free(sx_data);
  free(sy_data);
  free(nx_data);
  free(ny_data);
  free(J_data);
  free(sJ_data);
  free(fscale_data);
  free(reverse_data);
  for(int i = 0; i < 4; i++) {
    free(op_tmp_data[i]);
  }

  delete cubature;
  delete gauss;
}

void DGMesh::init() {
  op_par_loop_init_nodes("init_nodes",cells,
              op_arg_dat(node_coords,-3,cell2nodes,2,"double",OP_READ),
              op_arg_dat(nodeX,-1,OP_ID,3,"double",OP_WRITE),
              op_arg_dat(nodeY,-1,OP_ID,3,"double",OP_WRITE));

  // Calculate geometric factors
  init_grid_blas(this);

  op_par_loop_init_grid("init_grid",cells,
              op_arg_dat(rx,-1,OP_ID,DG_NP,"double",OP_RW),
              op_arg_dat(ry,-1,OP_ID,DG_NP,"double",OP_RW),
              op_arg_dat(sx,-1,OP_ID,DG_NP,"double",OP_RW),
              op_arg_dat(sy,-1,OP_ID,DG_NP,"double",OP_RW),
              op_arg_dat(nx,-1,OP_ID,3 * DG_NPF,"double",OP_WRITE),
              op_arg_dat(ny,-1,OP_ID,3 * DG_NPF,"double",OP_WRITE),
              op_arg_dat(J,-1,OP_ID,DG_NP,"double",OP_WRITE),
              op_arg_dat(sJ,-1,OP_ID,3 * DG_NPF,"double",OP_WRITE),
              op_arg_dat(fscale,-1,OP_ID,3 * DG_NPF,"double",OP_WRITE));

  op_par_loop_init_edges("init_edges",edges,
              op_arg_dat(edgeNum,-1,OP_ID,2,"int",OP_READ),
              op_arg_dat(nodeX,-2,edge2cells,3,"double",OP_READ),
              op_arg_dat(nodeY,-2,edge2cells,3,"double",OP_READ),
              op_arg_dat(reverse,-1,OP_ID,1,"bool",OP_WRITE));

  cubature->init();
  // gauss->init();
}
